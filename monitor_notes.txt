
// Inspired by 'monitors' from that operating systems book

bb_unprotected_add(buffer) {
	assert_held(add_mtx);
	acquire(spinlock);	// protect against add or remove
	<actually add to buffer...>
	release(spinlock);
}

bb_wait_add(buffer) {
	acquire(add_mtx);	// ensure only one person can be adding at once
				// (people can still subtract though). this ensures that once
				// there is room in the buffer, there will continue to be room in 
				// the buffer until we release this.

	acquire(reverse_sem);	// wait for there to be room in the buffer
	
	// requires the caller to call release(&add_mtx) at some point - either after they check the 
	// condition (e.g. for a 'block until this becomes available' call), or after they add something
	// e.g. a blocking add

}

same thing goes for the 'get', it uses a 'get_mtx' to protect against multiple getters.

the 'try' calls work the same, but timeout on 'reverse_sem' and 'add_mtx'.

bb_is_addable(buffer, timeout) {
	res = acquire(add_mtx, timeout)
	if (res == EAGAIN) {
		return false
	}
	
	// this is safe as we hold the `add_mtx` lock - it can't go from non-full to full
	// while we hold this (it can go from non-full to even-less-full, but that doesn't
	// effect our condition here
	acquire(spinlock)
	bool has_room = reverse_sem.val != full
	release(spinlock)

	if (!has_room) {
		release(add_mtx)
	}
	return has_room
}

bb_is_addable_already_got_lock(buffer) {
	acquire(spinlock)
	bool has_room = reverse_sem.val != full
	release(spinlock)
	return has_room
}

Notice how we leave the `add_mtx` acquired if we return true - this means that there will be
no race until we release this, allowing us to put an unprotected_add call after a successful
is_addable. call release(add_mtx) after adding the byte, or straight away if not interested in 
actually reading.

therefore we have 5 locks:
	- sem
	- reverse_sem
	- add_mtx
	- get_mtx
	- spinblock

e.g.
now we might have a read() call that wraps this (e.g. for a pty / keyboard / pipe / etc.)
blockable would be set to the value of O_NONBLOCK in most cases, but other things, such as select()
may have a use for setting blockable to a particular value (probably false)

read(buffer, count, blockable, data) {
	bool can_add = bb_is_addable()
	if (!can_add) {
		if (!blockable) return EAGAIN;
		bb_wait_add()
	}
	
	// allows us to check if has data with 'count = 0' without reading anything
	if (count > 0) {
		do {
			bb_add_unprotected(*data++)	
		} while (--count && bb_is_addable_already_got_lock())
	}
	release(add_mtx);
}
