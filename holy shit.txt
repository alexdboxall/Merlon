Ok some deeper looking has revealed that the problem seems to be:
    - one nested LowerIrql sets it to 0 (walking down the levels)
    - this causes us to task switch
    - another LowerIrql sets it to 1 (walking "down" the levels)

So it seems like we need LowerIrql to check if it is nested and is trying to lower below what
the parent is lowering it to. In this case, we need to keep Schedule()ing until the IRQL drops such that we can do it properly.

Looking at the logs...

Notice "doing postponed task switch, at level 1, nesting 2. thr 0xC0114FBC" happens at IRQL 1.
    HandleSleepWakeups
    raise 1 -> 2
    lower 2 -> 1 [2]
    ... -> 1 [2]
    doing postponed task switch, at level 1, nesting 2. thr 0xC0114FBC

We then switch tasks, and a whole lot of stuff happens. 

Then we get this:
    lower 40 -> 2 [1]
    ... -> 2 [1]
    lower 2 -> 0 [1]
    ... -> 0 [1]
    resuming 0xC0114FBC after a postponed task switch.
    handler returned.
    ... -> 1 [0]
    raise 1 -> 40

The task we switched to lowered the IRQL from 1 to 0. But this was a nested LowerIrql, and the parent
was actually only trying to get down to IRQL 1.

(from the above snippet).
    lower 2 -> 1 [2]
    ... -> 1 [2]
    doing postponed task switch, at level 1, nesting 2. thr 0xC0114FBC

So what we need to do (?) in this case is:
    - detect that a nested LowerIrql is trying to go lower than the parent IRQL (in a different thread).
    - call Schedule(), and wait for the parent LowerIrql to lower it.
    - then run what we need to do

OR: Work out how the other task managed to get it down to IRQL 0 in the first place
    was it from a spinlock release? a rouge LowerIrql? a situation where the "int irql = RaiseIrql(); ...; LowerIrql(irql)" 
    pattern isn't guaranteed to work (does task switching have anything to do with it?)

CRIKEY!! Looking at the first bit of the logs below:

    raise 1 -> 40
    lower 40 -> 1 [1]
    ... -> 1
    HandleSleepWakeups
    raise 1 -> 2
    lower 2 -> 1 [2]
    ... -> 1 [2]
    doing postponed task switch, at level 1, nesting 2. thr 0xC0114FBC
    raise 1 -> 2
    raise 2 -> 40
    lower 40 -> 2 [2]
    ... -> 2 [2]
    raise 2 -> 40
    lower 40 -> 2 [2]
    ... -> 2 [2]
    raise 2 -> 40
    lower 40 -> 2 [2]
    ... -> 2 [2]
    raise 2 -> 41
    lower 41 -> 2 [2]
    ... -> 2 [2]
    raise 2 -> 40
    lower 40 -> 2 [2]
    ... -> 2 [2]
    lower 2 -> 1 [2]
    ... -> 1 [2]
    resuming 0xC011518C after a postponed task switch.
    handler returned.
    ... -> 0 [1]
    raise 0 -> 2

We can see it again switches task, which causes a rouge lower to go below what the other task was expecting.
Ah, this wasn't a problem before, as IRQL_SCHEDULER and above forbid tasks switching. But now we have IRQL_PAGE_FAULT
allowed to task switch, we see these problems, that our existing IRQL system doesn't actually work properly between
tasks... It seems fixable by tweaking LowerIrql to handle such cases...




The full logs:



raise 1 -> 40
lower 40 -> 1 [1]
 ... -> 1
HandleSleepWakeups
raise 1 -> 2
lower 2 -> 1 [2]
 ... -> 1 [2]
doing postponed task switch, at level 1, nesting 2. thr 0xC0114FBC
raise 1 -> 2
raise 2 -> 40
lower 40 -> 2 [2]
 ... -> 2 [2]
raise 2 -> 40
lower 40 -> 2 [2]
 ... -> 2 [2]
raise 2 -> 40
lower 40 -> 2 [2]
 ... -> 2 [2]
raise 2 -> 41
lower 41 -> 2 [2]
 ... -> 2 [2]
raise 2 -> 40
lower 40 -> 2 [2]
 ... -> 2 [2]
lower 2 -> 1 [2]
 ... -> 1 [2]
resuming 0xC011518C after a postponed task switch.
handler returned.
 ... -> 0 [1]
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
adding symbol isdigit -> 0xC0101082
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
adding symbol isblank -> 0xC010106C
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
adding symbol iscntrl -> 0xC0101056
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
adding symbol isalnum -> 0xC0101034
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
adding symbol isalpha -> 0xC0101020
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
adding symbol tolower -> 0xC0101010
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
adding symbol toupper -> 0xC0101000
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
the semaphore is 0xC0113F94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
raise 0 -> 2
releasing semaphore...
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
raise 2 -> 2
lower 2 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
Requiring driver: sys:/vesa.sys
raise 0 -> 2
the semaphore is 0xC0113FB4
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> 0 [1]
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
loading driver...
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
lower 2 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 2
the semaphore is 0xC0114B94
ABOUT TO UNLOCK SCHEDULER.
lower 2 -> raise 2 -> 40
lower 40 -> 2 [1]
 ... -> 2 [1]
0 [1]
 ... -> 1
HandleSleepWakeups
raise 1 -> 2
lower 2 -> 1 [2]
 ... -> 1 [2]
handler returned.
 ... -> 0 [1]
UNLOCKED SCHEDULER. THIS SHOULD NOT APPEAR IMMEDIATELY IF WE NEEDED TO BLOCK FOR THE SEMAPHORE.
ide poll delay...
raise 0 -> 40
lower 40 -> 0 [1]
 ... -> 0 [1]
raise 0 -> 40
lower 40 -> 0 [1]
 ... -> 0 [1]
SleepUntil... irql = 0
raise 0 -> 2
Blocking thread...
Will block at next possible schedule...
lower 2 -> 0 [1]
 ... -> 0 [1]
doing postponed task switch, at level 0, nesting 1. thr 0xC011518C
raise 0 -> 2
raise 2 -> 40
lower 40 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 40
lower 40 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 40
lower 40 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 41
lower 41 -> 2 [1]
 ... -> 2 [1]
raise 2 -> 40
lower 40 -> 2 [1]
 ... -> 2 [1]
lower 2 -> 0 [1]
 ... -> 0 [1]
resuming 0xC0114FBC after a postponed task switch.
handler returned.
 ... -> 1 [0]
raise 1 -> 40







Page fault!
    IRQL goes from 0 -> 1
    IRQL goes from 1 -> 2 (as we need to lock the VAS)
    Realises we need to load from the disk
    Defers the disk read until IRQL 1
    We unlock the VAS. This causes LowerIrql
    LowerIrql:
        IRQL goes from 2 -> 1 (we've unlocked the VAS)
        Handler:
            Disk read starts
            Disk read calls 'sleep'
            IRQL goes from 1 -> 2 (scheduler lock)
            Task state goes into 'sleep', task switch postpones
            Unlock scheduler
            LowerIrql:
                IRQL goes from 2 -> 1 (scheduler unlock)
                BUT! Because this is a nested LowerIrql, \
                    and we're in IRQL_PAGE_FAULT,  
                    it doesn't cause a task switch!! \
                    Therefore, we're put in the sleep state, \
                    but not actually put to sleep / blocked!
                
Why do we need nested LowerIrqls to not cause a task switch when 
we're at IRQL_PAGE_FAULT??

If we allowed that to happen, then this happens :

TASK 1:
    IRQL 0
    Timer comes
    IRQ 0 -> 40
    HandleSleepWakeups deferred until IRQL 1
    IRQL 40 -> 0
        -> 1
            Task switch!
            TASK 2:
                does stuff (IRQL is still at 1)
                ...
                ...
                causes task switch!
                TASK 3:
                    does stuff (IRQL is still at 1)
                    ...
                    ...
                    causes task switch!
                    TASK 1:
                        IRQL 1 -> 0
    
As we can see, we get stuck at IRQL 1 until we get back to the original task.
The problem is, this happens every time we get a timer, so we don't
really ever get back down to IRQL 0. And this means we don't call EvictPage()
and that means we run out of RAM.

The fix (for this particular case - I bet there are other cases where this 
kind of nonsense happens)?

Make VAS locks use mutexes instead of spinlocks. Then the inner page fault code can
run at IRQL_PAGE_FAULT instead of IRQL_SCHEDULER, meaning the disk accesses
no longer need to be defered. This removes the nested LowerIrql...
This might(?) fix it for this case?


OR!! Task switches only occur from nested handlers that are at the 'target'
level of the parent IRQL.

e.g. in the first example, the nested LowerIrql task switch would happen, 
as it is trying to do it from IRQL 1, which is where the parent LowerIrql 
is going. What if multiple defered handlers within the parent one? Uhh.. I don't know.